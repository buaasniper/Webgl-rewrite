\section{Evaluation} \label{sec:eval}

We evaluate \sys prototype on three metrics: anti-fingerprinting capability, performance, and compatibility. % in Section~\ref{subsec:antifing} and performance in Section~\ref{subsec:per}. 

%\subsection{Benchmarks}







%\subsection{Rendering Results}

\subsection{Anti-fingerprinting Capability} \label{subsec:antifing}


\begin{table*}[t]
\scriptsize \centering
\caption{Macro-benchmark WebGL Tasks~\cite{ndss17cao} and Corresponding Rendering Results with  \sys (
%In ``WebGL task column'', AA means anti-aliasing, texture is one with random colors, and two models mean a monkey head plus a sofa model. 
 ``\# Vertices'' means the number of vertices in the model, which are two per line segment in a 2D model and three per triangle in a 3D model. ``Example'' is one rendering example collected from users.  In ``\# Unique Results'' columns, X/Y means the number of unique fingerprints collected from all the users out of the total number of fingerprints. ``FPS'' means frames per second -- which is around 60 Hz due to the screen refresh rate. Note that FPS might be a little bit higher than 60 Hz because of measurement errors introduced by browsers' reduced precision in $performane.now$.) } %\vspace{-0.1in} 
 \label{tab:result}
\begin{tabular}{lccccccccc}
\toprule
\multirow{4}{*}{\bf \footnotesize WebGL Task} & \multirow{4}{*}{\bf\footnotesize \# Vertices} & \multicolumn{5}{c}{\bf Original} & \multicolumn{3}{c}{\bf \sys} \\
\cmidrule(lr){3-7} \cmidrule(lr){8-10}
&  & \multirow{2}{*}{\bf Example} & \multicolumn{3}{c}{\bf \# Unique Results}  &\multirow{2}{*}{\bf FPS}  & \multirow{2}{*}{\bf Example} & \multirow{2}{*}{\bf \# Unique Results}  & \multirow{2}{*}{\bf FPS}  \\
\cmidrule(lr){4-6}
&  &  & Chrome & Firefox&Safari  &   &  &    &   \\
%\multicolumn{2}{c}{\bf FPS}  \\
 % \cmidrule(lr){5-6} %\cmidrule(lr){9-10}
% & & {\bf  Example} & {\bf Unique Results} & & {\bf Result}  & {\bf Unique Results} & \\
 %& Hardware & Software \\
\midrule \footnotesize
Curve and Line & \footnotesize 262 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/line_normal.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 6/139 & \footnotesize 60.32$\pm$0.38  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/line_normal.png} & \footnotesize 1/139 &\footnotesize  61.77$\pm$0.54 \\
\footnotesize Curve and Line (AA) & \footnotesize 262 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/line_aa.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 10/139 & \footnotesize 60.78$\pm$0.54  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/line_aa.png} & \footnotesize 1/139 & \footnotesize 61.83$\pm$0.97 \\
\footnotesize Cube & \footnotesize 36 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/cubenormal.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 6/139 & \footnotesize 60.67$\pm$0.49  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/cubenormal.png} & \footnotesize 1/139 & \footnotesize 62.50$\pm$0.80 \\
\footnotesize Cube (AA) & \footnotesize 36 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/cubeaa.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 8/139 & \footnotesize 60.46$\pm$0.15  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/cubeaa.png} & \footnotesize 1/139 & \footnotesize 62.39$\pm$1.36 \\
\footnotesize Cube (Camera) & \footnotesize 36 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/camera.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 7/139 &\footnotesize  60.02$\pm$0.22  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/camera.png} &\footnotesize  1/139 & \footnotesize 61.75$\pm$1.32 \\
\footnotesize Monkey head (Texture) & \footnotesize 2,904 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/texture_susan.png} & \footnotesize 6/139& \footnotesize 6/139&\footnotesize  10/139 & \footnotesize 60.14$\pm$1.17  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/texture_susan.png} & \footnotesize 1/139 & \footnotesize 61.88$\pm$1.61 \\
\footnotesize Monkey head (Light) & \footnotesize 2,904 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/simple_light_susan.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 10/139 & \footnotesize 59.95$\pm$0.60  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/simple_light_susan.png} & \footnotesize 1/139 & \footnotesize 61.07$\pm$1.02 \\
\footnotesize Two models (Light) & \footnotesize 2,988 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/simple_light_combined.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 9/139 & \footnotesize 60.02$\pm$1.19  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/simple_light_combined.png} & \footnotesize 1/139 & \footnotesize 61.90$\pm$0.97 \\
\footnotesize Two models (Complex light) & \footnotesize 2,988 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/more_light.png}& \footnotesize 6/139& \footnotesize 6/139& \footnotesize 16/139 & \footnotesize 60.18$\pm$0.40  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/more_light.png} & \footnotesize 1/139 & \footnotesize 60.02$\pm$1.13 \\
\footnotesize Two models (Texture) & \footnotesize 2,988 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/texture_combined.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 9/139 & \footnotesize 60.31$\pm$0.54  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/texture_combined.png} & \footnotesize 1/139 & \footnotesize 62.33$\pm$1.22 \\
\footnotesize Two models (Transparency) & \footnotesize 2,988 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/transparent.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 12/139 & \footnotesize 59.97$\pm$1.13  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/transparent.png} & \footnotesize 1/139 & \footnotesize 60.13$\pm$1.76 \\
\footnotesize Two models (Tex\&Light) & \footnotesize 2,988 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/two_texture_more_light.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 10/139 & \footnotesize 60.04$\pm$0.31  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/two_texture_more_light.png} & \footnotesize 1/139 & \footnotesize 59.74$\pm$0.75\\
\footnotesize Thousands of rings & \footnotesize 5,376 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/lighting_w.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 10/139 & \footnotesize 60.52$\pm$0.53  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/lighting_u.png} & \footnotesize 1/139 & \footnotesize 57.47$\pm$1.87\\
\footnotesize Clipping plane & \footnotesize 36 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/cliping_w.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 10/139 & \footnotesize 59.98$\pm$0.44  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/cliping_u.png} & \footnotesize 1/139 & \footnotesize 59.67$\pm$1.29\\
\footnotesize Bubble & \footnotesize 974 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/bubble_w.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 10/139 & \footnotesize 60.20$\pm$1.52  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/bubble_u.png} & \footnotesize 1/139 & \footnotesize 60.07$\pm$1.43\\
\footnotesize Compressed Texture & \footnotesize 98 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/compressed_w.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 10/139 & \footnotesize 60.04$\pm$0.56  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/compressed_u.png} & \footnotesize 1/139 & \footnotesize 59.59$\pm$0.73\\
\footnotesize Shadow & \footnotesize 156 & \includegraphics[width=0.08\columnwidth, valign=c]{figs/webgl/shadow_w.png} & \footnotesize 6/139& \footnotesize 6/139& \footnotesize 10/139 & \footnotesize 59.84$\pm$0.35  & \includegraphics[width=0.08\columnwidth, valign=c]{figs/unigl/shadow_u.png} & \footnotesize 1/139 & \footnotesize 60.12$\pm$1.02\\
\midrule
\footnotesize Combined fingerprint & & & \footnotesize 82/139& \footnotesize 82/139& \footnotesize 82/139 &  & & \footnotesize 1/139 & \\
%Varying & & \includegraphics[width=0.08\columnwidth, valign=c]{1.png} & 30 & 60  & \includegraphics[width=0.08\columnwidth, valign=c]{1.png} & 1/139 & 60 \\
\bottomrule
\end{tabular}
\end{table*}

We adopt a state-of-the-art WebGL-based browser fingerprinting work~\cite{ndss17cao} as our benchmark to evaluate the anti-fingerprinting capability and performance of \sys.   Specifically, the benchmark contains 17 different WebGL rendering tasks including plain WebGL tasks and these relying on three.js, a WebGL library, to explore various WebGL features, such as varyings, light and texture.   The first column of Table~\ref{tab:result} shows the names of all the rendering tasks and the second column a rendering result example on a dell desktop installed with Windows 10. % (TODO). 


%17 different rendering tasks exploring various WebGL features, such varyings, light and texture.  13 of the rendering tasks are written in GLSL language directly and the rest four are written with three.js, a popular WebGL library.  The first column of Table~\ref{tab:result} shows the names of all the rendering tasks and the second column a rendering result example on a dell desktop installed with Windows 10 (TODO). 

We evaluate \sys by asking Amazon Mechanical Turks to visit our demo website using Google Chrome for fingerprint collection. % and collecting fingerprints.  
 In the first round of our experiments, we observe three unique results among 106 fingerprints collected from the turks.  We then go back, analyze the results and find a bug, i.e., we do not handle integer overflows in a proper way.  Therefore, we fix the bug and re-perform all of experiments on Amazon Mechanical Turks and the results are shown in Table~\ref{tab:result}.  Among all 139 fingerprints, \sys only renders one unique fingerprint for each rendering task.  This unique fingerprint, being visually the same to the original rendering result, is shown in the ``Example'' column under \sys of Table~\ref{tab:result}.
 
 
 As a comparison, we also use the original fingerprinting work from Cao et al.\ to fingerprint each Turk together with our demo website---the number of unique results is shown in Table~\ref{tab:result}.  In total, we collect 82 unique fingerprints from 139 users, which can be broken down by different tasks shown in the ``\# Unique Results'' column under ``Original'' of Table~\ref{tab:result}.  That is, we confirm Cao et al.'s findings that WebGL is a high-entropy vector for browser fingerprinting. 

%running all therendering tasks with 

\subsection{Performance} \label{subsec:per}


We test the performance of \sys by using both micro- and macro-benchmarks.  All the experiments, except for the crowdsourced results in Table~\ref{tab:result}, are performed on an iMac -- the machine has an Intel Core i5, 3.2 Hz, 4-core CPU, 24 GB memory, and an AMD Radeon R9 M390 GPU with 2048 MB VRAM. 

% XXX CPU and YYY memory.   



\subsubsection{Micro-benchmark}


\begin{figure}
%\vspace{-4ex}
%\begin{center}
%\vspace{-0.2in}
\centering
%\vspace{-0.25in}
\includegraphics[width=\columnwidth]{vertex.eps} % was .08
%\vspace{-0.1in}
\vspace{-0.35in}
\caption{Micro-benchmark of Vertex Shader. }
\label{fig:vertex}
\vspace{-0.15in}
%\vspace{-0.2in}
%\end{center}
\end{figure} 

In the micro-benchmark, we test several atomic WebGL operations and compare the original version with the one defined in \sys.  Specifically, we run each operation in either fragment or vertex shader for 2,000 times and calculate the interval between two draws.  Each experiment is performed 20 times to obtain a standard deviation.  Note that we adopt a simple model, i.e., a cube, in the micro-benchmark experiment.  When we are testing one shader, the other shader will contain a one-line, dummy statement, i.e., the assignment of either $gl\_Position$ or $gl\_FragColor$. 





Figure~\ref{fig:vertex} shows the micro-benchmark performance of the vertex shader.  The vertex shader of \sys outperforms the one written in GLSL in some aspects, such as these operations that have integers involved.  The reason is that CPU is well designed for integer operation when compared with GPU.  On the contrary, the original shader written in GLSL is better at  matrix operations, because such operations can be performed in parallel using shading languages. 
 

%As expected, the vertex shader of \sys is constantly slower than the one of WebGL, because all the operations are performed in JavaScript rather than the real vertex shader.  

%One thing worth noting is that %Note that 
 %the vertex shader is used less often than the fragment shader as the number of vertices increases. That is, say $N$ is the number of vertices.  The time complexity for the vertex shader, no matter in JavaScript or the real shader, is $O(N)$, while the complexity for the fragment shader is $O(N^2)$.  That is, why \sys can still afford using JavaScript in its rewritten vertex shader. 
 
 %That is why we focus on the performance of the fragment shader. 

\begin{figure}
%\vspace{-4ex}
%\begin{center}
\centering
%\vspace{-0.25in}
\includegraphics[width=\columnwidth]{fragment.eps} % was .08
%\vspace{-0.1in}
\vspace{-0.35in}
\caption{Micro-benchmark of Fragment Shader. }
\label{fig:fragment}
\vspace{-0.15in}
%\vspace{-0.2in}
%\end{center}
\end{figure} 


Figure~\ref{fig:fragment} shows the micro-benchmark performance of the fragment shader.  Similar to the vertex shader, while \sys is slower than the original WebGL in some cases, such as ``texture2D'' as \sys redefines the function, it is worth noting that \sys is faster than the original WebGL in many other cases, such as ``pow'' and ``multiplication''.  The reason is that an integer operation is indeed sometimes cheaper than a floating-point one.  For example, it takes less time to multiply two integers than two floating-point values.  


%\begin{figure}
%\vspace{-4ex}
%\begin{center}
%\centering
%\vspace{-0.25in}
%\includegraphics[width=\columnwidth]{vertex.eps} % was .08
%\vspace{-0.1in}
%\vspace{-0.35in}
%\caption{Performance of \sys vs. the Number of Vertices. }
%\label{fig:vertexnum}
%\vspace{-0.15in}
%\vspace{-0.2in}
%\end{center}
%\end{figure} 


%We also change the number vertices in the WebGL model and observe the performance of \sys. The vertex and fragment shader adopted in this experiment are minimized---the vertex shader directly accepts the values in an attribute variable as the vertices and the fragment shader paints the model with a single color.  Figure~\ref{fig:vertexnum} shows the results....TODO

\subsubsection{Macro-benchmark}

In this subsection, we use the WebGL tasks provided by Cao et al.~\cite{ndss17cao} as our macro-benchmark to measure the FPS of these rendered by \sys.  The column ``FPS'' under \sys of Table~\ref{tab:result} shows the FPS of each rendering task and we also show the FPS without \sys, i.e., these rendered directly by WebGL in the same table.  The performance of \sys can satisfy the required screen refresh rate, i.e., 60 Hz. 
 The FPS of \sys for all the tasks are similar to the original one rendered by WebGL alone. 
 
 There are two things worth noting.  First, the FPS of \sys is even sometimes a little bit higher than the one of WebGL.  The reason is that when the model is simple, our highly optimized vertex shader with the help of WebAssembly is faster than the original one.  Second, the FPSes of both \sys and WebGL are a little bit higher than 60 Hz in some tasks, because modern browsers reduce the precision of $performance.now$ to prevent timing attacks~\cite{performancenowprecision}, which may lead to a small measurement error.  Such measurement errors are consistent across \sys and WebGL. 
 
 %Therefore, such measurement error will 
 
 
 %The introduction of light and transparency brings a little overhead, because a light-related task involves multiple matrix multiplication and \sys needs to order triangles based on z-buffer and calculates a combination of colors when rendering a transparent model.
 
 
%For simple tasks, such as cube with varyings and monkey head with texture, the FPS of \sys is similar to the original one.  The introduction of light and transparency are the most time-consuming operations for \sys.  The reason is as follows. %because 
% , which is a slow operation of \sys as shown in our micro-benchmark. 
% Further, . 
 % Therefore, the FPS of tasks involving lights and transparency drop a little bit to above 30. 
 
% Note that  the FPS of \sys is much higher than the one of software rendering (like 20--30 FPS), a computer graphics technique widely adopted in many scenarios when GPU is unavailable or incompatible with the browser.  The reason is that \sys can be considered as a combination of software and hardware rendering -- the vertex shader is rendered by CPU, but the rendering bottleneck, i.e., the fragment shader and the rasterization and interpolation, are still rendered by GPU.  
 
 %On the other hand, we believe that a FPS over 30 Hz is acceptable by human eyes.  For example, many movies are filmed at 24 FPS~\cite{24p}, which can be viewed by human beings without any problem.  Therefore, the FPS of \sys, much higher than 30 Hz, should be acceptable by human eyes. 

%Texture mapping 

\begin{table}
\footnotesize \centering
\caption{Overhead Breakdown for the ``Two models (Complex light)'' Task} \vspace{-0.1in} 
 \label{tab:breakdown}
\begin{tabular}{lc}
\toprule
{\bf Procedure} & {\bf Overhead} \\
\midrule
Data Preparation & 0.08$\pm$0.07ms\\
Backface Culling &  2.16$\pm$0.06ms\\
Vertex Shader & 2.26$\pm$0.18ms\\
Rendering Task Division & 5.34$\pm$0.73ms \\
Fragment Shader & 6.51$\pm$0.85ms\\
\midrule
Total &  16.35$\pm$0.74ms\\
\bottomrule
\end{tabular}
%\vspace{-0.1in}
\end{table}

We further look at one specific task, i.e., ``Two models (Complex light)'', and analyze the overhead brought by \sys.  Table~\ref{tab:breakdown} shows the overhead breakdown by different procedures of \sys. 
 The rendering task devision and fragment shader are the most time-consuming procedures, i.e., each taking one third of the entire overhead.  Both data preparation and backface culling are lightweight, taking up a small portion of the overhead. 

%The vertex and fragment shaders of \sys are the most time-consuming procedure, i.e., one third of the entire overhead, because it is written in JavaScript.  Note that we did not enable WebAssembly optimization in this experiment---if we do, the overhead is further reduced to around 2ms.  Then, the fragment shader takes 5.51ms and the rendering task division takes 4.34ms, as these two are another main pieces of \sys.  Both data preparation and backface culling are lightweight, taking up a small portion of the overhead.  


\begin{table}
\footnotesize \centering
\caption{Vertex Shader Optimization (all numbers are averaged from 10 experiments and rounded to ms)} %\vspace{-0.1in} 
 \label{tab:op}
\begin{tabular}{lc}
\toprule
{Unoptimized Vertex Shader} & 110 ms \\
\midrule
Result Caching of Matrix Operation& -24 ms \\
Typed, Fixed-size Array for Data & -22 ms \\
Code and Data Separation & -39 ms\\
Parallelization & -19 ms \\
WebAssembly & -4 ms \\
\midrule
Optimized Vertex Shader &  2 ms\\
\bottomrule
\end{tabular}%\vspace{-0.2in}
\end{table}

We then look at how our optimization reduces overhead of \sys, especially the vertex shader, using the same task.  Specifically, we evaluate five optimizations and their impact on the performance in Table~\ref{tab:op}. 
%
%, i.e., result caching (as mentioned in Section~\ref{subsec:rendering}) and four optimization (i.e., typed array, code and data separation, and fixed-size array as mentioned in Section~\ref{sec:impl}).   
  %shows the effectiveness all four optimizations.  
   The unoptimized vertex shader in JavaScript takes 110ms and each optimization reduces the overhead to some degree.  Code and data separation is the most effective one, i.e., about 40ms reduction, because JIT engine will execute code natively rather than on an interpreter.   Then, both caching and typed, fixed-size array speed up the shader by reducing around 20ms, and %the adoption of 
 parallelization also reduces the overhead by around 19ms. Lastly, if we apply WebAssembly optimization, the overhead can also be reduced by 4 ms. 

%and WebGL.

%, i.e., WebGL tasks provided 

\subsection{Compatibility}

In this section, we evaluate the compatibility of \sys with existing WebGL applications.  Specifically, in addition to the WebGL tasks from Cao et al.~\cite{ndss17cao}, we run \sys using two other real-world WebGL applications shown below:

\begin{icompact}
\item {Zygote Body.}  Zygote Body (\url{https://www.zygotebody.com/}), formerly known as Google Body, is created by Zygote Media Group to renders a manipulable 3D model of human body from outside, such asskins, muscle tissues and hairs, to inside, such as blood vessels and skeletons. 

%a web application by Zygote Media Group that renders manipulable 3D anatomical models of the human body
\item {Google I/O 2011 Applications.}  Google has presented WebGL applications (https://webglsamples.org/google-io/2011/index.html) at its I/O event in 2011 to show the new technique and performance. 
\end{icompact} 


\begin{figure}[t]
	\centering
	\subfloat[Zygote Body]{%
		\includegraphics[clip,height=0.45\columnwidth]{./body.png}%
	} 
	\subfloat[Google I/O Application]{%
		\includegraphics[clip,height=0.45\columnwidth]{./io.png}%
	} %\newline
	\vspace{-0.1in}%\captionsetup{justification=centering,margin=1cm}
	\caption{Two Screenshots of Zygote (Google) Body and Google I/O Application Rendered by \sys} \label{fig:screenshot} \vspace{-0.2in}
\end{figure}


Our evaluation result shows that \sys is compatible with both applications.  First, we run \sys with Zygote Body---the human body is rendered correctly with no visual difference.  We can also move the body and manipulate it by looking at different layers, such as skeleton and muscle. Second, we run \sys with Google I/O applications---all the objects are shown and displayed correctly with the right texture, moving on the canvas the same as ones with WebGL directly.  Two screenshots of both applications are also shown in Figure~\ref{fig:screenshot}.






