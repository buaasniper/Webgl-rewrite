// Generated by CoffeeScript 1.10.0

/*
This test uses a depth texture to do shadow mapping
A depth texture uses the webgl float texture extension and the webgl
depth texture extensions.  This is testing whether those extensions exist
and how they are implemented on the GPU
 */

(function() {
  var ShadowTest;

  window.ShadowTest = ShadowTest = (function() {
    function ShadowTest() {
      this.id = sender.getID();
    }

    ShadowTest.prototype.begin = function(canvas, cb) {
      
      __ColorFlag = 0;  // 0代表不需要颜色，1代表需要颜色。
      __Mworld_flag = 1;
      __Mview_flag = 1;
      __Mpro_flag = 1;
      __Drawnumber = 1;

      var Filter, boxFilter, camDist, camPitch, camProj, camRot, camView, counter, cubeGeom, depth, displayShader, downsample256, downsample512, draw, drawCamera, drawLight, drawScene, error, error1, floatExt, gl, lightDepthTexture, lightFramebuffer, lightProj, lightRot, lightShader, lightView, model, offset, planeGeom, quad;
      this.cb = cb;
      try {
        gl = new WebGLFramework(canvas, {
          antialias: false,
          preserveDrawingBuffer: true,
          willReadFrequently: false,
          depth: true
        }).depthTest();
        floatExt = gl.getFloatExtension({
          require: ['renderable', 'filterable'],
          prefer: ['single', 'half']
        });
        gl.getExt('OES_standard_derivatives');
      } catch (error1) {
        error = error1;
        console.log(error);
        return;
      }
      // 导入三个attribute  数据在meshes.js 中
      cubeGeom = gl.drawable(meshes.cube);   
      planeGeom = gl.drawable(meshes.plane(50));
      quad = gl.drawable(meshes.quad);
      displayShader = gl.shader({
        common: "//essl\nuniform mat4 lightProj, lightView; uniform mat3 lightRot;\nuniform mat4 model;",
        vertex: "//essl\nprecision mediump float;\nattribute vec2 vertPosition;\nvoid main(){\n    gl_Position =  vec4(vertPosition, 0.0, 1.0);\n    gl_PointSize = 1.0;\n }",
        fragment: "//essl\nprecision mediump float;\nstruct DirectionalLight{ivec3 direction;\nivec3 color;\n}\nuniform ivec3 tri_point[333];\nuniform ivec2 text_point[333];\nuniform int tri_number;\nstruct tri_p {int x0, y0, x1, y1, z1, x2, y2, z2, x3,  y3, z3;\n};\nstruct txt_p { int x1, y1, x2, y2, x3,  y3;\n};\nstruct txt_coord{int x, y;\n};\n#define uniformNumber 336\n#define init tri_p tri; txt_p texcoord; int z; z = -512;gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);int z0; txt_coord fragTexCoord;\n#define assign tri.x0 = int(gl_FragCoord.x); tri.y0 = int(gl_FragCoord.y); tri.x1 = tri_point[i][0]; tri.y1 = tri_point[i][1]; tri.z1 = tri_point[i][2]; tri.x2 = tri_point[i+1][0]; tri.y2 = tri_point[i+1][1]; tri.z2 = tri_point[i+1][2]; tri.x3 = tri_point[i+2][0]; tri.y3 = tri_point[i+2][1]; tri.z3 = tri_point[i+2][2];texcoord.x1 = text_point[i][0]; texcoord.y1 = text_point[i][1];texcoord.x2 = text_point[i+1][0]; texcoord.y2 = text_point[i+1][1];texcoord.x3 = text_point[i+2][0]; texcoord.y3 = text_point[i+2][1];\n#define cal_Zbuffer z0 = cal_z(tri);\n#define pixel_on_triangle ( i < (tri_number * 3) ) && (judge(tri) == 1)\n#define draw_pixel (z0 >= -512) && (z0 <= 512) && (z0 > z)\n#define renew_Zbuffer z = z0; fragTexCoord = calCoord(texcoord, tri);\nint judge(tri_p t);\nint f_judge(tri_p t);\nint PinAB(int tx0, int ty0, int tx1, int ty1, int tx2, int ty2);\nint f_PinAB(float tx0, float ty0, float tx1, float ty1, float tx2, float ty2);\nint cal_z(tri_p tri);\nint division(int a, int b);\nint mod(int a, int b); \nint isqrt(int a);\ntxt_coord calCoord(txt_p f, tri_p t);\nivec4 D_texture2D(sampler2D sampler,txt_coord t);\nivec4 cal_color(vec4 color0, vec4 color1, vec4 color2, vec4 color3, int wei_x, int wei_y);\nivec3 D_normalize(ivec3 a);\nvec4 col_transfer(ivec4 color); \nvec4 color0, color1, color2, color3;\n uniform ivec3 nor_point[333];\n int  wei_1, wei_2, wei_3;\n int judge(tri_p t) {\nif (( PinAB(t.x0 - t.x1, t.y0 - t.y1, t.x2 - t.x1, t.y2 - t.y1, t.x3 - t.x1, t.y3 - t.y1)+ PinAB(t.x0 - t.x2, t.y0 - t.y2, t.x3 - t.x2, t.y3 - t.y2, t.x1 - t.x2, t.y1 - t.y2)+ PinAB(t.x0 - t.x3, t.y0 - t.y3, t.x2 - t.x3, t.y2 - t.y3, t.x1 - t.x3, t.y1 - t.y3) == 3)  )\n{return 1;\n}\nelse\n{return 0;\n}\n}\nint PinAB(int tx0, int ty0, int tx1, int ty1, int tx2, int ty2){ \n int kb, kc; kb = tx0*ty1 - tx1*ty0; kc = tx0*ty2 - tx2*ty0;\nif  ( ((0 >= kb ) && (0 <= kc )) || ((0  <= kb ) && (0 >= kc)) ) \nreturn 1;\nreturn 0\n}\nint f_judge(tri_p t){\nif ( f_PinAB( float(t.x0 - t.x1), float(t.y0 - t.y1), float(t.x2 - t.x1), float(t.y2 - t.y1), float(t.x3 - t.x1), float(t.y3 - t.y1))+ f_PinAB( float(t.x0 - t.x2), float(t.y0 - t.y2), float(t.x3 - t.x2), float(t.y3 - t.y2), float(t.x1 - t.x2), float(t.y1 - t.y2))+ f_PinAB( float(t.x0 - t.x3), float(t.y0 - t.y3), float(t.x2 - t.x3), float(t.y2 - t.y3), float(t.x1 - t.x3), float(t.y1 - t.y3)) == 3)\n{return 1;\n}\nelse\n{return 0;\n}\n}\nint f_PinAB(float tx0, float ty0, float tx1, float ty1, float tx2, float ty2){ \nfloat kb, kc;\n kb = tx0*ty1 - tx1*ty0;\n kc = tx0*ty2 - tx2*ty0;\nif  ( ((0.0001 > kb) && (-0.0001 < kc)) || ((-0.0001 < kb) && (0.0001 > kc)) )\n {return 1;\n} return 0; \n}\nint cal_z(tri_p t){\nint A, B, C , D , K;\nA = (t.y3 - t.y1)*(t.z3 - t.z1) - (t.z2 - t.z1)*(t.y3 - t.y1);\nB = (t.x3 - t.x1)*(t.z2 - t.z1) - (t.x2 - t.x1)*(t.z3 - t.z1);\nC = (t.x2 - t.x1)*(t.y3 - t.y1) - (t.x3 - t.x1)*(t.y2 - t.y1);\nD = -1 * (A * t.x1 + B * t.y1 + C * t.z1);\nreturn (-1 *  division( (A * t.x0 + B * t.y0 + D) , C));\n}\nint division(int a, int b){\nint n = a / b;\nif ( (n - 2) * b >= a )\nreturn (n - 3);\nelse if ( (n - 1) * b >= a )\nreturn (n - 2);\nelse if ( b * n >= a )\nreturn (n - 1);\nelse if ( (n + 1) * b >= a )\nreturn n ;\nelse\n return (n + 1);\n}\nint mod(int a, int b){\nint n = a / b;\nif ( (n - 2) * b >= a )\nreturn a - (n - 3) * b;\n else if ( (n - 1) * b >= a )\nreturn a - (n - 2) * b;\n else if ( b * n >= a )\nreturn a - (n - 1) * b;\nelse if ( (n + 1) * b >= a )\nreturn a - n * b;\nelse\nreturn a - (n + 1) * b;\n}\ntxt_coord calCoord(txt_p f, tri_p t){\ntxt_coord tt;\nint bcs1, bcs2, bcs3, cs1, cs2, cs3;\nbcs1 = (t.x0 * t.y2 + t.x2 * t.y3 + t.x3 * t.y0) - (t.x3 * t.y2 + t.x2 * t.y0 + t.x0 * t.y3);\ncs1 =  (t.x1 * t.y2 + t.x2 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y2 + t.x2 * t.y1 + t.x1 * t.y3);\nwei_1 = division(bcs1 * 1000, cs1);\nbcs2 = (t.x1 * t.y0 + t.x0 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y0 + t.x0 * t.y1 + t.x1 * t.y3);\n cs2 =  (t.x1 * t.y2 + t.x2 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y2 + t.x2 * t.y1 + t.x1 * t.y3);\nwei_2 = division(bcs2 * 1000, cs2);\nbcs3 = (t.x1 * t.y2 + t.x2 * t.y0 + t.x0 * t.y1) - (t.x0 * t.y2 + t.x2 * t.y1 + t.x1 * t.y0);\ncs3 =  (t.x1 * t.y2 + t.x2 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y2 + t.x2 * t.y1 + t.x1 * t.y3);\nwei_3 = division(bcs3 * 1000, cs3);\ntt.x = wei_1 * f.x1 + wei_2 * f.x2 + wei_3 * f.x3;\ntt.y = wei_1 * f.y1 + wei_2 * f.y2 + wei_3 * f.y3;\nreturn tt;\n}\nivec4 D_texture2D(sampler2D sampler,txt_coord t){\nint tx0, ty0, wei_x, wei_y;\ntx0 = division ( t.x, 1000);\nty0 = division ( t.y, 1000);\ncolor0 = texture2D(sampler, vec2 ( (float(tx0 ) + 0.1) / 255.0 , (float(ty0) + 0.1)/ 255.0));\ncolor1 = texture2D(sampler, vec2 ( float(tx0 + 1)/ 255.0 , float(ty0     )/ 255.0));\ncolor2 = texture2D(sampler, vec2 ( float(tx0    )/ 255.0 , float(ty0  + 1)/ 255.0));\ncolor3 = texture2D(sampler, vec2 ( float(tx0 + 1)/ 255.0 , float(ty0  + 1)/ 255.0));\nwei_x = mod (t.x, 1000);\nwei_y = mod (t.y, 1000);\nreturn cal_color(color0, color1, color2, color3, wei_x, wei_y);\n}\nivec4 cal_color(vec4 color0, vec4 color1, vec4 color2, vec4 color3, int wei_x, int wei_y){\nint r, g, b;\nr = division( int(color0[0] * 255.0 + 0.1) * (1000 - wei_x) * (1000 - wei_y) + int(color1[0] * 255.0 + 0.1) * wei_x * (1000 - wei_y) + int(color2[0] * 255.0 + 0.1) * (1000 - wei_x) * wei_y + int(color3[0] * 255.0 + 0.1) * wei_x * wei_y, 1000000);g = division( int(color0[1] * 255.0 + 0.1) * (1000 - wei_x) * (1000 - wei_y) + int(color1[1] * 255.0 + 0.1) * wei_x * (1000 - wei_y) + int(color2[1] * 255.0 + 0.1) * (1000 - wei_x) * wei_y + int(color3[1] * 255.0 + 0.1) * wei_x * wei_y, 1000000);\nb = division( int(color0[2] * 255.0 + 0.1) * (1000 - wei_x) * (1000 - wei_y) + int(color1[2] * 255.0 + 0.1) * wei_x * (1000 - wei_y) + int(color2[2] * 255.0 + 0.1) * (1000 - wei_x) * wei_y + int(color3[2] * 255.0 + 0.1) * wei_x * wei_y, 1000000);\nreturn ivec4( r, g, b, 100 );\n}\nvec4 col_transfer( ivec4 c){\nreturn vec4 (  float(c[0])/255.0, float(c[1])/255.0, float(c[2])/255.0, float(c[3])/ 100.0);\n}\nivec3 D_normalize(ivec3 a){\nint rate = isqrt (division(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], 100)) ;\nreturn ivec3( division( a[0] * rate, 10),  division( a[1] * rate, 10), division( a[2] * rate, 10));\n}\nint isqrt(int a){\nfor (int i = 0; i < 1000; i++)\nif (i * i >= a)\n return i;\n}\nfloat linstep(float low, float high, float v){\n    return clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(sampler2D depths, vec2 uv, float compare){\n    vec2 moments = texture2D(depths, uv).xy;\n    float p = smoothstep(compare-0.02, compare, moments.x);\n    float variance = max(moments.y - moments.x*moments.x, -0.001);\n    float d = compare - moments.x;\n    float p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n    return clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat attenuation(vec3 dir){\n    float dist = length(dir);\n    float radiance = 1.0/(1.0+pow(dist/10.0, 2.0));\n    return clamp(radiance*10.0, 0.0, 1.0);\n}\n\nfloat influence(vec3 normal, float coneAngle){\n    float minConeAngle = ((360.0-coneAngle-10.0)/360.0)*PI;\n    float maxConeAngle = ((360.0-coneAngle)/360.0)*PI;\n    return smoothstep(minConeAngle, maxConeAngle, acos(normal.z));\n}\n\nfloat lambert(vec3 surfaceNormal, vec3 lightDirNormal){\n    return max(0.0, dot(surfaceNormal, lightDirNormal));\n}\n\nvec3 skyLight(vec3 normal){\n    return vec3(smoothstep(0.0, PI, PI-acos(normal.y)))*0.4;\n}\n\nvec3 gamma(vec3 color){\n    return pow(color, vec3(2.2));\n}\n\nvoid main(){\n    init;\n for (int i = 0; i < uniformNumber; i+= 3){\n assign;\nif ( pixel_on_triangle ){\ncal_Zbuffer;\nif ( draw_pixel ){\n renew_Zbuffer;\n vec3 worldNormal = normalize(vWorldNormal);\n\n    vec3 camPos = (camView * vWorldPosition).xyz;\n    vec3 lightPos = (lightView * vWorldPosition).xyz;\n    vec3 lightPosNormal = normalize(lightPos);\n    vec3 lightSurfaceNormal = lightRot * worldNormal;\n    vec4 lightDevice = lightProj * vec4(lightPos, 1.0);\n    vec2 lightDeviceNormal = lightDevice.xy/lightDevice.w;\n    vec2 lightUV = lightDeviceNormal*0.5+0.5;\n\n    // shadow calculation\n    float lightDepth2 = clamp(length(lightPos)/40.0, 0.0, 1.0);\n    float illuminated = VSM(sLightDepth, lightUV, lightDepth2);\n\n    vec3 excident = (\n        skyLight(worldNormal) +\n        lambert(lightSurfaceNormal, -lightPosNormal) *\n        influence(lightPosNormal, 55.0) *\n        attenuation(lightPos) *\n        illuminated\n    );\n    gl_FragColor = vec4(gamma(excident), 1.0);\n}"
      });
      lightShader = gl.shader({
        common: "//essl\nuniform mat4 lightProj, lightView; uniform mat3 lightRot;\nuniform mat4 model;",
        vertex: "//essl\nprecision mediump float;\nattribute vec2 vertPosition;\nvoid main(){\n    gl_Position =  vec4(vertPosition, 0.0, 1.0);\n    gl_PointSize = 1.0;\n}",
        fragment: "//essl\n#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\nstruct DirectionalLight{ivec3 direction;\nivec3 color;\n}\nuniform ivec3 tri_point[333];\nuniform ivec2 text_point[333];\nuniform int tri_number;\nstruct tri_p {int x0, y0, x1, y1, z1, x2, y2, z2, x3,  y3, z3;\n};\nstruct txt_p { int x1, y1, x2, y2, x3,  y3;\n};\nstruct txt_coord{int x, y;\n};\n#define uniformNumber 336\n#define init tri_p tri; txt_p texcoord; int z; z = -512;gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);int z0; txt_coord fragTexCoord;\n#define assign tri.x0 = int(gl_FragCoord.x); tri.y0 = int(gl_FragCoord.y); tri.x1 = tri_point[i][0]; tri.y1 = tri_point[i][1]; tri.z1 = tri_point[i][2]; tri.x2 = tri_point[i+1][0]; tri.y2 = tri_point[i+1][1]; tri.z2 = tri_point[i+1][2]; tri.x3 = tri_point[i+2][0]; tri.y3 = tri_point[i+2][1]; tri.z3 = tri_point[i+2][2];texcoord.x1 = text_point[i][0]; texcoord.y1 = text_point[i][1];texcoord.x2 = text_point[i+1][0]; texcoord.y2 = text_point[i+1][1];texcoord.x3 = text_point[i+2][0]; texcoord.y3 = text_point[i+2][1];\n#define cal_Zbuffer z0 = cal_z(tri);\n#define pixel_on_triangle ( i < (tri_number * 3) ) && (judge(tri) == 1)\n#define draw_pixel (z0 >= -512) && (z0 <= 512) && (z0 > z)\n#define renew_Zbuffer z = z0; fragTexCoord = calCoord(texcoord, tri);\nint judge(tri_p t);\nint f_judge(tri_p t);\nint PinAB(int tx0, int ty0, int tx1, int ty1, int tx2, int ty2);\nint f_PinAB(float tx0, float ty0, float tx1, float ty1, float tx2, float ty2);\nint cal_z(tri_p tri);\nint division(int a, int b);\nint mod(int a, int b); \nint isqrt(int a);\ntxt_coord calCoord(txt_p f, tri_p t);\nivec4 D_texture2D(sampler2D sampler,txt_coord t);\nivec4 cal_color(vec4 color0, vec4 color1, vec4 color2, vec4 color3, int wei_x, int wei_y);\nivec3 D_normalize(ivec3 a);\nvec4 col_transfer(ivec4 color); \nvec4 color0, color1, color2, color3;\n uniform ivec3 nor_point[333];\n int  wei_1, wei_2, wei_3;\n int judge(tri_p t) {\nif (( PinAB(t.x0 - t.x1, t.y0 - t.y1, t.x2 - t.x1, t.y2 - t.y1, t.x3 - t.x1, t.y3 - t.y1)+ PinAB(t.x0 - t.x2, t.y0 - t.y2, t.x3 - t.x2, t.y3 - t.y2, t.x1 - t.x2, t.y1 - t.y2)+ PinAB(t.x0 - t.x3, t.y0 - t.y3, t.x2 - t.x3, t.y2 - t.y3, t.x1 - t.x3, t.y1 - t.y3) == 3)  )\n{return 1;\n}\nelse\n{return 0;\n}\n}\nint PinAB(int tx0, int ty0, int tx1, int ty1, int tx2, int ty2){ \n int kb, kc; kb = tx0*ty1 - tx1*ty0; kc = tx0*ty2 - tx2*ty0;\nif  ( ((0 >= kb ) && (0 <= kc )) || ((0  <= kb ) && (0 >= kc)) ) \nreturn 1;\nreturn 0\n}\nint f_judge(tri_p t){\nif ( f_PinAB( float(t.x0 - t.x1), float(t.y0 - t.y1), float(t.x2 - t.x1), float(t.y2 - t.y1), float(t.x3 - t.x1), float(t.y3 - t.y1))+ f_PinAB( float(t.x0 - t.x2), float(t.y0 - t.y2), float(t.x3 - t.x2), float(t.y3 - t.y2), float(t.x1 - t.x2), float(t.y1 - t.y2))+ f_PinAB( float(t.x0 - t.x3), float(t.y0 - t.y3), float(t.x2 - t.x3), float(t.y2 - t.y3), float(t.x1 - t.x3), float(t.y1 - t.y3)) == 3)\n{return 1;\n}\nelse\n{return 0;\n}\n}\nint f_PinAB(float tx0, float ty0, float tx1, float ty1, float tx2, float ty2){ \nfloat kb, kc;\n kb = tx0*ty1 - tx1*ty0;\n kc = tx0*ty2 - tx2*ty0;\nif  ( ((0.0001 > kb) && (-0.0001 < kc)) || ((-0.0001 < kb) && (0.0001 > kc)) )\n {return 1;\n} return 0; \n}\nint cal_z(tri_p t){\nint A, B, C , D , K;\nA = (t.y3 - t.y1)*(t.z3 - t.z1) - (t.z2 - t.z1)*(t.y3 - t.y1);\nB = (t.x3 - t.x1)*(t.z2 - t.z1) - (t.x2 - t.x1)*(t.z3 - t.z1);\nC = (t.x2 - t.x1)*(t.y3 - t.y1) - (t.x3 - t.x1)*(t.y2 - t.y1);\nD = -1 * (A * t.x1 + B * t.y1 + C * t.z1);\nreturn (-1 *  division( (A * t.x0 + B * t.y0 + D) , C));\n}\nint division(int a, int b){\nint n = a / b;\nif ( (n - 2) * b >= a )\nreturn (n - 3);\nelse if ( (n - 1) * b >= a )\nreturn (n - 2);\nelse if ( b * n >= a )\nreturn (n - 1);\nelse if ( (n + 1) * b >= a )\nreturn n ;\nelse\n return (n + 1);\n}\nint mod(int a, int b){\nint n = a / b;\nif ( (n - 2) * b >= a )\nreturn a - (n - 3) * b;\n else if ( (n - 1) * b >= a )\nreturn a - (n - 2) * b;\n else if ( b * n >= a )\nreturn a - (n - 1) * b;\nelse if ( (n + 1) * b >= a )\nreturn a - n * b;\nelse\nreturn a - (n + 1) * b;\n}\ntxt_coord calCoord(txt_p f, tri_p t){\ntxt_coord tt;\nint bcs1, bcs2, bcs3, cs1, cs2, cs3;\nbcs1 = (t.x0 * t.y2 + t.x2 * t.y3 + t.x3 * t.y0) - (t.x3 * t.y2 + t.x2 * t.y0 + t.x0 * t.y3);\ncs1 =  (t.x1 * t.y2 + t.x2 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y2 + t.x2 * t.y1 + t.x1 * t.y3);\nwei_1 = division(bcs1 * 1000, cs1);\nbcs2 = (t.x1 * t.y0 + t.x0 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y0 + t.x0 * t.y1 + t.x1 * t.y3);\n cs2 =  (t.x1 * t.y2 + t.x2 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y2 + t.x2 * t.y1 + t.x1 * t.y3);\nwei_2 = division(bcs2 * 1000, cs2);\nbcs3 = (t.x1 * t.y2 + t.x2 * t.y0 + t.x0 * t.y1) - (t.x0 * t.y2 + t.x2 * t.y1 + t.x1 * t.y0);\ncs3 =  (t.x1 * t.y2 + t.x2 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y2 + t.x2 * t.y1 + t.x1 * t.y3);\nwei_3 = division(bcs3 * 1000, cs3);\ntt.x = wei_1 * f.x1 + wei_2 * f.x2 + wei_3 * f.x3;\ntt.y = wei_1 * f.y1 + wei_2 * f.y2 + wei_3 * f.y3;\nreturn tt;\n}\nivec4 D_texture2D(sampler2D sampler,txt_coord t){\nint tx0, ty0, wei_x, wei_y;\ntx0 = division ( t.x, 1000);\nty0 = division ( t.y, 1000);\ncolor0 = texture2D(sampler, vec2 ( (float(tx0 ) + 0.1) / 255.0 , (float(ty0) + 0.1)/ 255.0));\ncolor1 = texture2D(sampler, vec2 ( float(tx0 + 1)/ 255.0 , float(ty0     )/ 255.0));\ncolor2 = texture2D(sampler, vec2 ( float(tx0    )/ 255.0 , float(ty0  + 1)/ 255.0));\ncolor3 = texture2D(sampler, vec2 ( float(tx0 + 1)/ 255.0 , float(ty0  + 1)/ 255.0));\nwei_x = mod (t.x, 1000);\nwei_y = mod (t.y, 1000);\nreturn cal_color(color0, color1, color2, color3, wei_x, wei_y);\n}\nivec4 cal_color(vec4 color0, vec4 color1, vec4 color2, vec4 color3, int wei_x, int wei_y){\nint r, g, b;\nr = division( int(color0[0] * 255.0 + 0.1) * (1000 - wei_x) * (1000 - wei_y) + int(color1[0] * 255.0 + 0.1) * wei_x * (1000 - wei_y) + int(color2[0] * 255.0 + 0.1) * (1000 - wei_x) * wei_y + int(color3[0] * 255.0 + 0.1) * wei_x * wei_y, 1000000);g = division( int(color0[1] * 255.0 + 0.1) * (1000 - wei_x) * (1000 - wei_y) + int(color1[1] * 255.0 + 0.1) * wei_x * (1000 - wei_y) + int(color2[1] * 255.0 + 0.1) * (1000 - wei_x) * wei_y + int(color3[1] * 255.0 + 0.1) * wei_x * wei_y, 1000000);\nb = division( int(color0[2] * 255.0 + 0.1) * (1000 - wei_x) * (1000 - wei_y) + int(color1[2] * 255.0 + 0.1) * wei_x * (1000 - wei_y) + int(color2[2] * 255.0 + 0.1) * (1000 - wei_x) * wei_y + int(color3[2] * 255.0 + 0.1) * wei_x * wei_y, 1000000);\nreturn ivec4( r, g, b, 100 );\n}\nvec4 col_transfer( ivec4 c){\nreturn vec4 (  float(c[0])/255.0, float(c[1])/255.0, float(c[2])/255.0, float(c[3])/ 100.0);\n}\nivec3 D_normalize(ivec3 a){\nint rate = isqrt (division(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], 100)) ;\nreturn ivec3( division( a[0] * rate, 10),  division( a[1] * rate, 10), division( a[2] * rate, 10));\n}\nint isqrt(int a){\nfor (int i = 0; i < 1000; i++)\nif (i * i >= a)\n return i;\n}\nvoid main(){\n    init;\n for (int i = 0; i < uniformNumber; i+= 3){\n assign;\nif ( pixel_on_triangle ){\ncal_Zbuffer;\nif ( draw_pixel ){\n renew_Zbuffer;\nvec3 worldNormal = normalize(vWorldNormal);\n    vec3 lightPos = (lightView * vWorldPosition).xyz;\n    float depth = clamp(length(lightPos)/40.0, 0.0, 1.0);\n    float dx = dFdx(depth);\n    float dy = dFdy(depth);\n    gl_FragColor = vec4(depth, pow(depth, 2.0) + 0.25*(dx*dx + dy*dy), 0.0, 1.0);\n}"
      });
      lightDepthTexture = gl.texture({
        type: floatExt.type,
        channels: 'rgba'
      }).bind().setSize(1024, 1024).linear().clampToEdge();
      lightFramebuffer = gl.framebuffer().bind().color(lightDepthTexture).depth().unbind();
      Filter = (function() {
        function Filter(size, filter) {
          this.size = size;
          this.output = gl.texture({
            type: floatExt.type,
            channels: 'rgba'
          }).bind().setSize(this.size, this.size).linear().clampToEdge();
          this.framebuffer = gl.framebuffer().bind().color(this.output).unbind();
          // 手动输入 texcoord = position*0.5+0.5 在attribute中
          this.shader = gl.shader({
            common: "//essl\n;",
            vertex: "//essl\nprecision mediump float;\nattribute vec2 vertPosition;\nvoid main(){\n    gl_Position =  vec4(vertPosition, 0.0, 1.0);\n}",
            fragment: "//essl\n//essl\nprecision mediump float;\nstruct DirectionalLight{ivec3 direction;\nivec3 color;\n}\nuniform ivec3 tri_point[333];\nuniform ivec2 text_point[333];\nuniform int tri_number;\nstruct tri_p {int x0, y0, x1, y1, z1, x2, y2, z2, x3,  y3, z3;\n};\nstruct txt_p { int x1, y1, x2, y2, x3,  y3;\n};\nstruct txt_coord{int x, y;\n};\n#define uniformNumber 336\n#define init tri_p tri; txt_p texcoord; int z; z = -512;gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);int z0; txt_coord fragTexCoord;\n#define assign tri.x0 = int(gl_FragCoord.x); tri.y0 = int(gl_FragCoord.y); tri.x1 = tri_point[i][0]; tri.y1 = tri_point[i][1]; tri.z1 = tri_point[i][2]; tri.x2 = tri_point[i+1][0]; tri.y2 = tri_point[i+1][1]; tri.z2 = tri_point[i+1][2]; tri.x3 = tri_point[i+2][0]; tri.y3 = tri_point[i+2][1]; tri.z3 = tri_point[i+2][2];texcoord.x1 = text_point[i][0]; texcoord.y1 = text_point[i][1];texcoord.x2 = text_point[i+1][0]; texcoord.y2 = text_point[i+1][1];texcoord.x3 = text_point[i+2][0]; texcoord.y3 = text_point[i+2][1];\n#define cal_Zbuffer z0 = cal_z(tri);\n#define pixel_on_triangle ( i < (tri_number * 3) ) && (judge(tri) == 1)\n#define draw_pixel (z0 >= -512) && (z0 <= 512) && (z0 > z)\n#define renew_Zbuffer z = z0; fragTexCoord = calCoord(texcoord, tri);\nint judge(tri_p t);\nint f_judge(tri_p t);\nint PinAB(int tx0, int ty0, int tx1, int ty1, int tx2, int ty2);\nint f_PinAB(float tx0, float ty0, float tx1, float ty1, float tx2, float ty2);\nint cal_z(tri_p tri);\nint division(int a, int b);\nint mod(int a, int b); \nint isqrt(int a);\ntxt_coord calCoord(txt_p f, tri_p t);\nivec4 D_texture2D(sampler2D sampler,txt_coord t);\nivec4 cal_color(vec4 color0, vec4 color1, vec4 color2, vec4 color3, int wei_x, int wei_y);\nivec3 D_normalize(ivec3 a);\nvec4 col_transfer(ivec4 color); \nvec4 color0, color1, color2, color3;\n uniform ivec3 nor_point[333];\n int  wei_1, wei_2, wei_3;\n int judge(tri_p t) {\nif (( PinAB(t.x0 - t.x1, t.y0 - t.y1, t.x2 - t.x1, t.y2 - t.y1, t.x3 - t.x1, t.y3 - t.y1)+ PinAB(t.x0 - t.x2, t.y0 - t.y2, t.x3 - t.x2, t.y3 - t.y2, t.x1 - t.x2, t.y1 - t.y2)+ PinAB(t.x0 - t.x3, t.y0 - t.y3, t.x2 - t.x3, t.y2 - t.y3, t.x1 - t.x3, t.y1 - t.y3) == 3)  )\n{return 1;\n}\nelse\n{return 0;\n}\n}\nint PinAB(int tx0, int ty0, int tx1, int ty1, int tx2, int ty2){ \n int kb, kc; kb = tx0*ty1 - tx1*ty0; kc = tx0*ty2 - tx2*ty0;\nif  ( ((0 >= kb ) && (0 <= kc )) || ((0  <= kb ) && (0 >= kc)) ) \nreturn 1;\nreturn 0\n}\nint f_judge(tri_p t){\nif ( f_PinAB( float(t.x0 - t.x1), float(t.y0 - t.y1), float(t.x2 - t.x1), float(t.y2 - t.y1), float(t.x3 - t.x1), float(t.y3 - t.y1))+ f_PinAB( float(t.x0 - t.x2), float(t.y0 - t.y2), float(t.x3 - t.x2), float(t.y3 - t.y2), float(t.x1 - t.x2), float(t.y1 - t.y2))+ f_PinAB( float(t.x0 - t.x3), float(t.y0 - t.y3), float(t.x2 - t.x3), float(t.y2 - t.y3), float(t.x1 - t.x3), float(t.y1 - t.y3)) == 3)\n{return 1;\n}\nelse\n{return 0;\n}\n}\nint f_PinAB(float tx0, float ty0, float tx1, float ty1, float tx2, float ty2){ \nfloat kb, kc;\n kb = tx0*ty1 - tx1*ty0;\n kc = tx0*ty2 - tx2*ty0;\nif  ( ((0.0001 > kb) && (-0.0001 < kc)) || ((-0.0001 < kb) && (0.0001 > kc)) )\n {return 1;\n} return 0; \n}\nint cal_z(tri_p t){\nint A, B, C , D , K;\nA = (t.y3 - t.y1)*(t.z3 - t.z1) - (t.z2 - t.z1)*(t.y3 - t.y1);\nB = (t.x3 - t.x1)*(t.z2 - t.z1) - (t.x2 - t.x1)*(t.z3 - t.z1);\nC = (t.x2 - t.x1)*(t.y3 - t.y1) - (t.x3 - t.x1)*(t.y2 - t.y1);\nD = -1 * (A * t.x1 + B * t.y1 + C * t.z1);\nreturn (-1 *  division( (A * t.x0 + B * t.y0 + D) , C));\n}\nint division(int a, int b){\nint n = a / b;\nif ( (n - 2) * b >= a )\nreturn (n - 3);\nelse if ( (n - 1) * b >= a )\nreturn (n - 2);\nelse if ( b * n >= a )\nreturn (n - 1);\nelse if ( (n + 1) * b >= a )\nreturn n ;\nelse\n return (n + 1);\n}\nint mod(int a, int b){\nint n = a / b;\nif ( (n - 2) * b >= a )\nreturn a - (n - 3) * b;\n else if ( (n - 1) * b >= a )\nreturn a - (n - 2) * b;\n else if ( b * n >= a )\nreturn a - (n - 1) * b;\nelse if ( (n + 1) * b >= a )\nreturn a - n * b;\nelse\nreturn a - (n + 1) * b;\n}\ntxt_coord calCoord(txt_p f, tri_p t){\ntxt_coord tt;\nint bcs1, bcs2, bcs3, cs1, cs2, cs3;\nbcs1 = (t.x0 * t.y2 + t.x2 * t.y3 + t.x3 * t.y0) - (t.x3 * t.y2 + t.x2 * t.y0 + t.x0 * t.y3);\ncs1 =  (t.x1 * t.y2 + t.x2 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y2 + t.x2 * t.y1 + t.x1 * t.y3);\nwei_1 = division(bcs1 * 1000, cs1);\nbcs2 = (t.x1 * t.y0 + t.x0 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y0 + t.x0 * t.y1 + t.x1 * t.y3);\n cs2 =  (t.x1 * t.y2 + t.x2 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y2 + t.x2 * t.y1 + t.x1 * t.y3);\nwei_2 = division(bcs2 * 1000, cs2);\nbcs3 = (t.x1 * t.y2 + t.x2 * t.y0 + t.x0 * t.y1) - (t.x0 * t.y2 + t.x2 * t.y1 + t.x1 * t.y0);\ncs3 =  (t.x1 * t.y2 + t.x2 * t.y3 + t.x3 * t.y1) - (t.x3 * t.y2 + t.x2 * t.y1 + t.x1 * t.y3);\nwei_3 = division(bcs3 * 1000, cs3);\ntt.x = wei_1 * f.x1 + wei_2 * f.x2 + wei_3 * f.x3;\ntt.y = wei_1 * f.y1 + wei_2 * f.y2 + wei_3 * f.y3;\nreturn tt;\n}\nivec4 D_texture2D(sampler2D sampler,txt_coord t){\nint tx0, ty0, wei_x, wei_y;\ntx0 = division ( t.x, 1000);\nty0 = division ( t.y, 1000);\ncolor0 = texture2D(sampler, vec2 ( (float(tx0 ) + 0.1) / 255.0 , (float(ty0) + 0.1)/ 255.0));\ncolor1 = texture2D(sampler, vec2 ( float(tx0 + 1)/ 255.0 , float(ty0     )/ 255.0));\ncolor2 = texture2D(sampler, vec2 ( float(tx0    )/ 255.0 , float(ty0  + 1)/ 255.0));\ncolor3 = texture2D(sampler, vec2 ( float(tx0 + 1)/ 255.0 , float(ty0  + 1)/ 255.0));\nwei_x = mod (t.x, 1000);\nwei_y = mod (t.y, 1000);\nreturn cal_color(color0, color1, color2, color3, wei_x, wei_y);\n}\nivec4 cal_color(vec4 color0, vec4 color1, vec4 color2, vec4 color3, int wei_x, int wei_y){\nint r, g, b;\nr = division( int(color0[0] * 255.0 + 0.1) * (1000 - wei_x) * (1000 - wei_y) + int(color1[0] * 255.0 + 0.1) * wei_x * (1000 - wei_y) + int(color2[0] * 255.0 + 0.1) * (1000 - wei_x) * wei_y + int(color3[0] * 255.0 + 0.1) * wei_x * wei_y, 1000000);g = division( int(color0[1] * 255.0 + 0.1) * (1000 - wei_x) * (1000 - wei_y) + int(color1[1] * 255.0 + 0.1) * wei_x * (1000 - wei_y) + int(color2[1] * 255.0 + 0.1) * (1000 - wei_x) * wei_y + int(color3[1] * 255.0 + 0.1) * wei_x * wei_y, 1000000);\nb = division( int(color0[2] * 255.0 + 0.1) * (1000 - wei_x) * (1000 - wei_y) + int(color1[2] * 255.0 + 0.1) * wei_x * (1000 - wei_y) + int(color2[2] * 255.0 + 0.1) * (1000 - wei_x) * wei_y + int(color3[2] * 255.0 + 0.1) * wei_x * wei_y, 1000000);\nreturn ivec4( r, g, b, 100 );\n}\nvec4 col_transfer( ivec4 c){\nreturn vec4 (  float(c[0])/255.0, float(c[1])/255.0, float(c[2])/255.0, float(c[3])/ 100.0);\n}\nivec3 D_normalize(ivec3 a){\nint rate = isqrt (division(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], 100)) ;\nreturn ivec3( division( a[0] * rate, 10),  division( a[1] * rate, 10), division( a[2] * rate, 10));\n}\nint isqrt(int a){\nfor (int i = 0; i < 1000; i++)\nif (i * i >= a)\n return i;\n}\nuniform vec2 viewport;\nuniform sampler2D source;\n\nvec3 get(float x, float y){\n    vec2 off = vec2(x, y);\n    return texture2D(source, texcoord+off/viewport).rgb;\n}\nvec3 get(int x, int y){\n    vec2 off = vec2(x, y);\n    return texture2D(source, texcoord+off/viewport).rgb;\n}\nvec3 filter(){\n    " + filter + "\n}\n void main(){\n init;\n for (int i = 0; i < uniformNumber; i+= 3){\n assign;\nif ( pixel_on_triangle ){\ncal_Zbuffer;\nif ( draw_pixel ){\n renew_Zbuffer;\n  gl_FragColor = vec4(filter(), 1.0);\n}"
          });
        }

        Filter.prototype.bind = function(unit) {
          return this.output.bind(unit);
        };

        Filter.prototype.apply = function(source) {
          this.framebuffer.bind();
          gl.viewport(0, 0, this.size, this.size);
          this.shader.use().vec2('viewport', this.size, this.size).sampler('source', source).draw(quad);
          return this.framebuffer.unbind();
        };

        return Filter;

      })();
      downsample512 = new Filter(512, "//essl\nreturn get(0.0, 0.0);");
      downsample256 = new Filter(256, "//essl\nreturn get(0.0, 0.0);");
      boxFilter = new Filter(256, "//essl\nvec3 result = vec3(0.0);\nfor(int x=-1; x<=1; x++){\n    for(int y=-1; y<=1; y++){\n        result += get(x,y);\n    }\n}\nreturn result/9.0;");
      camProj = gl.mat4();
      camView = gl.mat4();
      lightProj = gl.mat4().perspective({
        fov: 60
      }, 1, {
        near: 0.01,
        far: 100
      });
      lightView = gl.mat4().trans(0, 0, -6).rotatex(30).rotatey(110);
      lightRot = gl.mat3().fromMat4Rot(lightView);
      model = gl.mat4();
      counter = -Math.PI * 0.1;
      offset = 0;
      camDist = 10;
      camRot = 55;
      camPitch = 41;
      depth = 0;
      drawScene = function(shader) {
        return shader.mat4('model', model.ident().trans(0, 0, 0)).draw(planeGeom).mat4('model', model.ident().trans(0, 1 + offset, 0)).draw(cubeGeom).mat4('model', model.ident().trans(5, 1, -1)).draw(cubeGeom);
      };
      drawLight = function() {
        lightFramebuffer.bind();
        gl.viewport(0, 0, lightDepthTexture.width, lightDepthTexture.height).clearColor(1, 1, 1, 1).clearDepth(1).cullFace('back');
        lightShader.use().mat4('lightView', lightView).mat4('lightProj', lightProj).mat3('lightRot', lightRot);
        drawScene(lightShader);
        lightFramebuffer.unbind();
        downsample512.apply(lightDepthTexture);
        downsample256.apply(downsample512);
        return boxFilter.apply(downsample256);
      };
      drawCamera = function() {
        gl.adjustSize().viewport().cullFace('back').clearColor(0, 0, 0, 0).clearDepth(1);
        camProj.perspective({
          fov: 60,
          aspect: gl.aspect,
          near: 0.01,
          far: 100
        });
        camView.ident().trans(0, -1, -camDist).rotatex(camPitch).rotatey(camRot);
        displayShader.use().mat4('camProj', camProj).mat4('camView', camView).mat4('lightView', lightView).mat4('lightProj', lightProj).mat3('lightRot', lightRot).sampler('sLightDepth', boxFilter);
        return drawScene(displayShader);
      };
      draw = function() {
        drawLight();
        return drawCamera();
      };
      draw();
      return gl.animationInterval((function(_this) {
        return function(frame) {
          offset = 1 + Math.sin(counter);
          counter += 1 / 10;
          draw();
          if (depth++ === 5) {
            caf(frame);
            sender.getData(gl.getContext(), _this.id);
            return _this.cb();
          }
        };
      })(this));
    };

    return ShadowTest;

  })();

}).call(this);
